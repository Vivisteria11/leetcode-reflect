
### Problem: 15. 3Sum

ğŸ· Topic: Two Pointers

ğŸ¤– LLM Feedback:
Feedback:
Your solution is mostly correct, but it lacks efficiency and does not consider the duplicate triples.

Correctness: Your solution attempts to solve the 3Sum problem, but it does not handle duplicates in the input array. It does not return the correct result for arrays with duplicates.

Efficiency: Your solution has a time complexity of O(n^3), where n is the size of the input array. This is because your solution uses three nested loops to generate all possible triplets. This is less efficient than the optimal solution, which can be achieved with a time complexity of O(n^2).

Improvements: There are several ways to improve your solution. Firstly, you should handle duplicates in the input array. This can be achieved by ignoring duplicates when calculating the sum of each possible triplet. Secondly, you can use a two-pointer technique to improve the efficiency of your solution. This can be achieved by sorting the input array and then using two pointers to find the sum of each possible triplet.

ğŸ’» Your Code:
```cpp
classÂ SolutionÂ {
public:
Â Â Â Â vector<vector<int>>Â threeSum(vector<int>&Â nums)Â {
Â Â Â Â Â vector<int>Â ans;
Â Â Â Â Â vector<vector<int>>Â result;
Â Â Â Â Â intÂ val;
Â Â Â Â Â sort(nums.begin(),nums.end());

Â Â Â Â Â for(intÂ iÂ =Â 0;i<nums.size()-2;i++){

Â Â Â Â Â Â Â if(iÂ >Â 0Â &&Â nums[i]==nums[i-1])continue;//avoidÂ duplicateÂ 

Â Â Â Â Â Â Â intÂ leftÂ =Â iÂ +Â 1,Â rightÂ =Â nums.size()Â -Â 1;//[-4,-1,-1,0,1,2]Â isÂ theÂ sortedÂ arrayÂ soÂ indexÂ zeroÂ isÂ 
fixedÂ ,indexÂ 1Â isÂ left,lastÂ indexÂ is
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â whileÂ (leftÂ <Â right)Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â intÂ sumÂ =Â nums[i]Â +Â nums[left]Â +Â nums[right];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (sumÂ ==Â 0)Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â result.push_back({nums[i],Â nums[left],Â nums[right]});
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â whileÂ (leftÂ <Â rightÂ &&Â nums[left]Â ==Â nums[leftÂ +Â 1])Â left++;Â //Â SkipÂ duplicates
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â whileÂ (leftÂ <Â rightÂ &&Â nums[right]Â ==Â nums[rightÂ -Â 1])Â right--;Â //Â SkipÂ duplicates
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â left++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â right--;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }Â elseÂ ifÂ (sumÂ <Â 0)Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â left++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }Â elseÂ {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â right--;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
```
